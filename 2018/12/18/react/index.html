
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>个人学习记录博客 - 好好学习，天天向上！</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="数据接口景点·门票1234567891011121314@param lat 纬度@param lng 经度@param wxOpenId	微信openId@param bd_origin@para,"> 
    <meta name="author" content="MFC"> 
    <link rel="alternative" href="atom.xml" title="个人学习记录博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">react经典面试题</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">react经典面试题</h1>
        <div class="stuff">
            <span>十二月 18, 2018</span>
            

        </div>
        <div class="content markdown">
            <h4 id="1-什么是MVVM？"><a href="#1-什么是MVVM？" class="headerlink" title="1. 什么是MVVM？"></a>1. 什么是MVVM？</h4><h5 id="什么是MVVM"><a href="#什么是MVVM" class="headerlink" title="什么是MVVM"></a>什么是MVVM</h5><blockquote>
<p>MVVM是MVC的增强版，实质上和MVC没有本质区别，只是代码的位置变动而已</p>
</blockquote>
<p><strong>首先先来说一下什么是MVC：</strong></p>
<p>MVC，Model、View、Controller，分别表示数据、视图、控制器，所谓MVC便是这几个单词的简写，那么它们之间是怎么工作的呢？先看下图。<br><img src="https://upload-images.jianshu.io/upload_images/2002187-4d82bf5244e9d66e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/716/format/webp" alt="MVC"><br>上图简单描述了三者的作用</p>
<ul>
<li>Model：数据模型，用来存储数据</li>
<li>View：视图界面，用来展示UI界面和响应用户交互</li>
<li>Controller：控制器(大管家角色)，监听模型数据的改变和控制视图行为、处理用户交互</li>
</ul>
<p><strong>那么什么是MVVM呢？</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2002187-ddcaae06ec00dadb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/673/format/webp" alt="MVVM"></p>
<ul>
<li><p>MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</p>
</li>
<li><p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>
</li>
<li><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
</li>
</ul>
<hr>
<h4 id="2-React与Vue的区别与联系？"><a href="#2-React与Vue的区别与联系？" class="headerlink" title="2. React与Vue的区别与联系？"></a>2. React与Vue的区别与联系？</h4><p><strong>首先React与Vue有几点相同之处</strong></p>
<ol>
<li>都使用了Virtual DOM（虚拟DOM）</li>
<li>提供了响应式（Reactive）和组件化（Composable）的视图组件</li>
<li>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库</li>
</ol>
<p><strong>而他们的不同之处在于</strong></p>
<ol>
<li>React创造并使用了JSX语法，而Vue使用的是模板系统</li>
<li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li>
</ol>
<hr>
<h4 id="3-什么是JSX语法、Virtual-DOM与DOM-Diff算法？"><a href="#3-什么是JSX语法、Virtual-DOM与DOM-Diff算法？" class="headerlink" title="3. 什么是JSX语法、Virtual DOM与DOM Diff算法？"></a>3. 什么是JSX语法、Virtual DOM与DOM Diff算法？</h4><blockquote>
<h5 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h5><p>JSX语法简单来说就是在js代码中书写html语法，它是一种JavaScript语法扩展，在React中可以方便地用来描述UI。你可以在if语句或for循环中使用JSX，你可以将它赋值给变量，你可以将它作为参数接收，你也可以在函数中返回JSX。</p>
</blockquote>
<p>JSX本身也是一个表达式，在编译后，JSX表达式会变成普通的JavaScript对象。</p>
<p>可以将任何javascript代码用大括号{}包起来嵌入到JSX里面。</p>
<p>还可以指定JSX的参数，参数可以用字符串形式指定：<br><code>const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;</code><br>也可以用javascript表达式指定：<br><code>const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;</code></p>
<blockquote>
<h5 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h5><p>虚拟DOM概念随着react的诞生而诞生，由facebook提出，其卓越的性能很快得到广大开发者的认可；继react之后vue2.0也在其核心引入了虚拟DOM的概念。</p>
</blockquote>
<p>虚拟DOM可以看作是一个使用javascript模拟了DOM结构的树形结构，这个树结构包含整个DOM结构的信息，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;list&quot;&gt;</span><br><span class="line">  &lt;li&gt;item 1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 2&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: &apos;ul&apos;, </span><br><span class="line">    props: &#123;&apos;class&apos;: &apos;list&apos;&#125;, </span><br><span class="line">    children: [</span><br><span class="line">        &#123; type: &apos;li&apos;, props: &#123;&#125;, children: [&apos;item 1&apos;] &#125;,</span><br><span class="line">        &#123; type: &apos;li&apos;, props: &#123;&#125;, children: [&apos;item 2&apos;] &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见上边的DOM结构，不论是标签名称还是标签的属性或标签的子集，都会对应在下边的树结构里。</p>
<p>为什么要使用虚拟DOM？</p>
<p>因为在浏览器里一遍又一遍的渲染DOM是非常非常消耗性能的，常常会出现页面卡死的情况；所以尽量减少对DOM的操作成为了优化前端性能的必要手段，虚拟DOM就是将DOM的对比放在了js层，通过对比不同之处来选择新渲染DOM节点，从而提高渲染效率。</p>
<blockquote>
<h5 id="DOM-Diff算法"><a href="#DOM-Diff算法" class="headerlink" title="DOM Diff算法"></a>DOM Diff算法</h5><p>diff算法简单来说就是对比遍历新旧dom树，有新增就添加，有减少就删除，实现局部的dom更新，而不是重新渲染整个dom</p>
</blockquote>
<hr>
<h4 id="4-详细介绍生命周期-三个阶段，生命周期的触发顺序"><a href="#4-详细介绍生命周期-三个阶段，生命周期的触发顺序" class="headerlink" title="4. 详细介绍生命周期(三个阶段，生命周期的触发顺序)"></a>4. 详细介绍生命周期(三个阶段，生命周期的触发顺序)</h4><p>React生命周期主要分为三个阶段，顺序如下</p>
<ol>
<li><p><strong>实例化</strong></p>
<ul>
<li>constructor：用以初始化state,设置state默认值</li>
<li>componentWillMount：该方法在首次渲染之前调用，也是再 render 方法调用之前修改 state 的最后一次机会。<strong>17.0版本后将被移除</strong></li>
<li>render：将虚拟dom渲染成真实dom</li>
<li>componentDidMount：该方法在首次渲染之后调用，不会在服务端被渲染的过程中调用</li>
</ul>
</li>
<li><p><strong>存在期</strong></p>
<ul>
<li>componentWillReceiveProps：当props改变的时候触发，有1个参数nextProps。<strong>17.0版本后将被移除</strong></li>
<li>shouldComponentUpdate：当props 或者 state改变的时候触发，可以控制是否需要重新render，返回值为boolean</li>
<li>componentWillUpdate：这个方法和 componentWillMount 类似，在组件接收到了新的 props 或者 state 即将进行重新渲染前，componentWillUpdate(nextProps, nextState) 会被调用，注意不要在此方面里再去更新 props 或者 state。<strong>17.0版本后将被移除</strong></li>
<li>render</li>
<li>componentDidUpdate：这个方法和 componentDidMount 类似，在组件重新被渲染之后，componentDidUpdate(prevProps, prevState) 会被调用。可以在这里访问并修改 DOM</li>
</ul>
</li>
<li><p><strong>销毁期</strong></p>
<ul>
<li>componentWillUnmount：每当React使用完一个组件，这个组件必须从 DOM 中卸载后被销毁，此时 componentWillUnmout 会被执行，完成所有的清理和销毁工作，在 componentDidMount 中添加的任务都需要再该方法中撤销，如创建的定时器或事件监听器。</li>
</ul>
</li>
</ol>
<p><strong>17.0版本后，添加了2个新的生命周期</strong></p>
<ul>
<li>static getDerivedStateFromProps：会在初始化和update时触发，用于替换componentWillReceiveProps，可以用来控制 props 更新 state 的过程；它返回一个对象表示新的 state；如果不需要更新，返回 null 即可</li>
<li>getSnapshotBeforeUpdate：用于替换 componentWillUpdate，该函数会在update后 DOM 更新前被调用，用于读取最新的 DOM 数据，返回值将作为 componentDidUpdate 的第三个参数</li>
</ul>
<hr>
<h4 id="5-合成事件与改变this指向的三种方式及之间的区别？"><a href="#5-合成事件与改变this指向的三种方式及之间的区别？" class="headerlink" title="5. 合成事件与改变this指向的三种方式及之间的区别？"></a>5. 合成事件与改变this指向的三种方式及之间的区别？</h4><blockquote>
<h5 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h5><p>React并不是将click事件直接绑定在dom上面，而是采用事件冒泡的形式冒泡到document上面，然后React将事件封装给正式的函数处理运行和处理。</p>
</blockquote>
<p>如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。</p>
<ul>
<li>当用户在为onClick添加函数时，React并没有将Click时间绑定在DOM上面。</li>
<li>而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装交给中间层SyntheticEvent（负责所有事件合成）</li>
<li>所以当事件触发的时候，对使用统一的分发函数dispatchEvent将指定函数执行。</li>
</ul>
<blockquote>
<h5 id="改变this指向的三种方式及之间的区别"><a href="#改变this指向的三种方式及之间的区别" class="headerlink" title="改变this指向的三种方式及之间的区别"></a>改变this指向的三种方式及之间的区别</h5></blockquote>
<ol>
<li>call() 方法<br>语法：<br><code>call(thisObj, arg1, arg2, argN);</code><br>改变this指向后会自动执行，第一个参数为要指向的目标，后面的参数为要传递的数据</li>
<li>apply() 方法<br>语法：<br><code>apply(thisObj, [arg1, arg2, argN]);</code><br>改变this指向后会自动执行，第一个参数为要指向的目标，后面的参数为要传递的数据，格式为数组形式</li>
<li>bind() 方法<br>语法：<br><code>bind(thisObj, arg1, arg2, argN);</code><br>改变this指向后不会自动执行，第一个参数为要指向的目标，后面的参数为要传递的数据。</li>
<li>箭头函数<br>语法：<br><code>let XXX = () =&gt; {};</code><br>箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</li>
</ol>
<p>由于箭头函数是匿名函数，在页面刷新时会重新生成函数名，会造成页面不必要的渲染，所以在react中，改变this指向尽量使用bind方法。</p>
<hr>
<h4 id="6-样式绑定与CSS-Modules"><a href="#6-样式绑定与CSS-Modules" class="headerlink" title="6. 样式绑定与CSS Modules"></a>6. 样式绑定与CSS Modules</h4><blockquote>
<p>CSS模块就是所有的类名都只有局部作用域的CSS文件。<br>在React中，通过className来绑定类名，为了解决不同模块之间样式冲突的问题，使用了CSS Modules。</p>
</blockquote>
<p>CSS Modules提供了2个api</p>
<ul>
<li>:global()：用来将样式设置为全局样式</li>
<li>:local()：默认的api，用来将样式设置为局部样式</li>
</ul>
<p>使用CSS Modules之后，引用css需要使用import引入css文件并设置一个变量名，调用样式的格式变为<code>className={styles.box}</code></p>
<hr>
<h4 id="7-多种组件创建方式及其区别？"><a href="#7-多种组件创建方式及其区别？" class="headerlink" title="7. 多种组件创建方式及其区别？"></a>7. 多种组件创建方式及其区别？</h4><ol>
<li><p><strong>es5方法 React.createClass</strong><br>与无状态组件相比，React.createClass和后面要描述的React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。但是随着React的发展，React.createClass形式自身的问题暴露出来：</p>
<ul>
<li>React.createClass会自绑定函数方法（不像React.Component只绑定需要关心的函数）导致不必要的性能开销，增加代码过时的可能性。</li>
<li>React.createClass的mixins不够自然、直观；React.Component形式非常适合高阶组件（Higher Order Components–HOC）,它以更直观的形式展示了比mixins更强大的功能，并且HOC是纯净的JavaScript，不用担心他们会被废弃。HOC可以参考无状态组件(Stateless Component) 与高阶组件。</li>
</ul>
</li>
<li><p><strong>es6形式的extends React.Component定义的组件</strong><br>React.Component是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。</p>
</li>
<li><p><strong>无状态函数式组件</strong><br>创建无状态函数式组件形式是从React 0.14版本开始出现的。它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到要state状态的操作。具体的无状态函数式组件，其官方指出：</p>
<blockquote>
<p>在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。</p>
</blockquote>
<p> 无状态函数式组件形式上表现为一个只带有一个render方法的组件类，通过函数形式或者ES6 arrow function的形式在创建，并且该组件是无state状态的。具体的创建形式如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function HelloComponent(props, context) &#123;</span><br><span class="line">    return &lt;div&gt;Hello &#123;props.name&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;HelloComponent name=&quot;Sebastian&quot; /&gt;, mountNode)</span><br></pre></td></tr></table></figure>
<p> 无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点：</p>
<ul>
<li><strong>组件不会被实例化，整体渲染性能得到提升</strong><br>因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。</li>
<li><strong>组件不能访问this对象</strong><br>无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：this.ref、this.state等均不能访问。若想访问就不能使用这种形式来创建组件</li>
<li><strong>组件无法访问生命周期的方法</strong><br>因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。</li>
<li><p><strong>无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用</strong></p>
<p>无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以只要有可能，尽量使用无状态组件。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="8-什么是受控组件？"><a href="#8-什么是受控组件？" class="headerlink" title="8. 什么是受控组件？"></a>8. 什么是受控组件？</h4><p>假设我们现在有一个表单，表单中有一个input标签，input的value值必须是我们设置在constructor构造函数的state中的值，然后，通过onChange触发事件来改变state中保存的value值，这样形成一个循环的回路影响。也可以说是React负责渲染表单的组件仍然控制用户后续输入时所发生的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Demo1 extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            value: props.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange(e) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            value: e.target.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;input value=&#123;this.state.value&#125; onChange=&#123;e =&gt; this.handleChange(e)&#125;/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="9-高阶组件与装饰器"><a href="#9-高阶组件与装饰器" class="headerlink" title="9. 高阶组件与装饰器"></a>9. 高阶组件与装饰器</h4><blockquote>
<p>我们都知道高阶函数是什么，高阶组件其实是差不多的用法，只不过传入的参数变成了react组件，并返回一个新的组件。</p>
</blockquote>
<p>高阶组件是react应用中很重要的一部分，最大的特点就是重用组件逻辑。它并不是由React API定义出来的功能，而是由React的组合特性衍生出来的一种设计模式。如果你用过redux，那你就一定接触过高阶组件，因为react-redux中的connect就是一个高阶组件。</p>
<p>先来一个最简单的高阶组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import simpleHoc from &apos;./simple-hoc&apos;;</span><br><span class="line"></span><br><span class="line">class Usual extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(this.props, &apos;props&apos;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Usual</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default simpleHoc(Usual);</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const simpleHoc = WrappedComponent =&gt; &#123;</span><br><span class="line">  console.log(&apos;simpleHoc&apos;);</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;WrappedComponent &#123;```this.props&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default simpleHoc;</span><br></pre></td></tr></table></figure></p>
<p>组件Usual通过simpleHoc的包装，打了一个log</p>
<p>那么形如simpleHoc就是一个高阶组件了，通过接收一个组件class Usual，并返回一个组件class。 其实我们可以看到，在这个函数里，我们可以做很多操作。 而且return的组件同样有自己的生命周期，function，另外，我们看到也可以把props传给WrappedComponent(被包装的组件)</p>
<p><strong>装饰器</strong><br>高阶组件可以看做是装饰器模式(Decorator Pattern)在React的实现。即允许向一个现有的对象添加新的功能，同时又不改变其结构，属于包装模式(Wrapper Pattern)的一种</p>
<p>ES7中添加了一个decorator的属性，使用@符表示，可以更精简的书写。那上面的例子就可以改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import simpleHoc from &apos;./simple-hoc&apos;;</span><br><span class="line"></span><br><span class="line">@simpleHoc</span><br><span class="line">export default class Usual extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Usual</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是同样的效果。<br>当然兼容性是存在问题的，通常都是通过babel去编译的。 babel提供了plugin，高阶组件用的是类装饰器，所以用transform-decorators-legacy babel</p>
<hr>
<h4 id="10-组件通信的多种方式及其之间的区别"><a href="#10-组件通信的多种方式及其之间的区别" class="headerlink" title="10. 组件通信的多种方式及其之间的区别"></a>10. 组件通信的多种方式及其之间的区别</h4><p>在使用 React 的过程中，不可避免的需要组件间进行消息传递（通信），组件间通信大体有下面几种情况：</p>
<ol>
<li><p><strong>父组件向子组件通信</strong><br>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。<br> <strong>父组件 App.js：</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import Sub from &quot;./SubComponent.js&quot;;</span><br><span class="line">import &quot;./App.css&quot;;</span><br><span class="line"></span><br><span class="line">export default class App extends Component&#123;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Sub title = &quot;今年过节不收礼&quot; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>子组件 SubComponent.js：</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Sub = (props) =&gt; &#123;</span><br><span class="line">    return(</span><br><span class="line">        &lt;h1&gt;</span><br><span class="line">            &#123; props.title &#125;</span><br><span class="line">        &lt;/h1&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Sub;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>子组件向父组件通信</strong><br>利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。<br> <strong>SubComponent.js：</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Sub = (props) =&gt; &#123;</span><br><span class="line">    const cb = (msg) =&gt; &#123;</span><br><span class="line">        return () =&gt; &#123;</span><br><span class="line">            props.callback(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick = &#123; cb(&quot;我们通信把&quot;) &#125;&gt;点击我&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Sub;</span><br></pre></td></tr></table></figure>
<p> <strong>App.js：</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import Sub from &quot;./SubComponent.js&quot;;</span><br><span class="line">import &quot;./App.css&quot;;</span><br><span class="line"></span><br><span class="line">export default class App extends Component&#123;</span><br><span class="line">    callback(msg)&#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Sub callback = &#123; this.callback.bind(this) &#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>跨级组件之间通信</strong><br>所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</p>
<ul>
<li>中间组件层层传递 props</li>
<li><p>使用 context 对象</p>
<p>对于第一种方式，如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些  props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。</p>
<p>使用 context 是另一种可行的方式，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。</p>
<p>使用 context 也很简单，需要满足两个条件：</p>
</li>
<li>上级组件要声明自己支持 context，并提供一个函数来返回相应的context 对象</li>
<li><p>子组件要声明自己需要使用 context</p>
<p>下面以代码说明，我们新建 3 个文件：父组件 App.js，子组件 Sub.js，子组件的子组件 SubSub.js。<br><strong>App.js：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import PropTypes from &quot;prop-types&quot;;</span><br><span class="line">import Sub from &quot;./Sub&quot;;</span><br><span class="line">import &quot;./App.css&quot;;</span><br><span class="line"></span><br><span class="line">export default class App extends Component&#123;</span><br><span class="line">    // 父组件声明自己支持 context</span><br><span class="line">    static childContextTypes = &#123;</span><br><span class="line">        color:PropTypes.string,</span><br><span class="line">        callback:PropTypes.func,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 父组件提供一个函数，用来返回相应的 context 对象</span><br><span class="line">    getChildContext()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            color:&quot;red&quot;,</span><br><span class="line">            callback:this.callback.bind(this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callback(msg)&#123;</span><br><span class="line">        console.log(msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Sub&gt;&lt;/Sub&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Sub.js：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import SubSub from &quot;./SubSub&quot;;</span><br><span class="line"></span><br><span class="line">const Sub = (props) =&gt;&#123;</span><br><span class="line">    return(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;SubSub /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Sub;</span><br></pre></td></tr></table></figure>
<p><strong>SubSub.js：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import PropTypes from &quot;prop-types&quot;;</span><br><span class="line"></span><br><span class="line">export default class SubSub extends Component&#123;</span><br><span class="line">    // 子组件声明自己需要使用 context</span><br><span class="line">    static contextTypes = &#123;</span><br><span class="line">        color:PropTypes.string,</span><br><span class="line">        callback:PropTypes.func,</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        const style = &#123; color:this.context.color &#125;</span><br><span class="line">        const cb = (msg) =&gt; &#123;</span><br><span class="line">            return () =&gt; &#123;</span><br><span class="line">                this.context.callback(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div style = &#123; style &#125;&gt;</span><br><span class="line">                SUBSUB</span><br><span class="line">                &lt;button onClick = &#123; cb(&quot;我胡汉三又回来了！&quot;) &#125;&gt;点击我&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是父组件向子组件单向通信，可以使用变量，如果子组件想向父组件通信，同样可以由父组件提供一个回调函数，供子组件调用，回传参数。</p>
<p>在使用 context 时，有两点需要注意：</p>
<p>父组件需要声明自己支持 context，并提供 context 中属性的 PropTypes</p>
<p>子组件需要声明自己需要使用 context，并提供其需要使用的 context 属性的 PropTypes</p>
<p>父组件需提供一个 getChildContext 函数，以返回一个初始的 context 对象</p>
<p>如果组件中使用构造函数（constructor），还需要在构造函数中传入第二个参数 context，并在 super 调用父类构造函数是传入 context，否则会造成组件中无法使用 context。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor(props,context)&#123;</span><br><span class="line">super(props,context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>改变 context 对象</strong><br>我们不应该也不能直接改变 context 对象中的属性，要想改变 context 对象，只有让其和父组件的 state 或者 props 进行关联，在父组件的 state 或 props 变化时，会自动调用 getChildContext 方法，返回新的 context 对象，而后子组件进行相应的渲染。<br>修改 App.js，让 context 对象可变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import PropTypes from &quot;prop-types&quot;;</span><br><span class="line">import Sub from &quot;./Sub&quot;;</span><br><span class="line">import &quot;./App.css&quot;;</span><br><span class="line"></span><br><span class="line">export default class App extends Component&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            color:&quot;red&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 父组件声明自己支持 context</span><br><span class="line">    static childContextTypes = &#123;</span><br><span class="line">        color:PropTypes.string,</span><br><span class="line">        callback:PropTypes.func,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 父组件提供一个函数，用来返回相应的 context 对象</span><br><span class="line">    getChildContext()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            color:this.state.color,</span><br><span class="line">            callback:this.callback.bind(this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在此回调中修改父组件的 state</span><br><span class="line">    callback(color)&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            color,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Sub&gt;&lt;/Sub&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，在子组件的 cb 方法中，传入相应的颜色参数，就可以改变 context 对象了，进而影响到子组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">return(</span><br><span class="line">    &lt;div style = &#123; style &#125;&gt;</span><br><span class="line">        SUBSUB</span><br><span class="line">        &lt;button onClick = &#123; cb(&quot;blue&quot;) &#125;&gt;点击我&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>context 同样可以应在无状态组件上，只需将 context 作为第二个参数传入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import PropTypes from &quot;prop-types&quot;;</span><br><span class="line"></span><br><span class="line">const SubSub = (props,context) =&gt; &#123;</span><br><span class="line">    const style = &#123; color:context.color &#125;</span><br><span class="line">    const cb = (msg) =&gt; &#123;</span><br><span class="line">        return () =&gt; &#123;</span><br><span class="line">            context.callback(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return(</span><br><span class="line">        &lt;div style = &#123; style &#125;&gt;</span><br><span class="line">            SUBSUB</span><br><span class="line">            &lt;button onClick = &#123; cb(&quot;我胡汉三又回来了！&quot;) &#125;&gt;点击我&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubSub.contextTypes = &#123;</span><br><span class="line">    color:PropTypes.string,</span><br><span class="line">    callback:PropTypes.func,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default SubSub;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>非嵌套组件间通信</strong><br>非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</p>
<ul>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li><p>使用自定义事件的方式</p>
<p>如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以…<br>这里我们采用自定义事件的方式来实现非嵌套组件间的通信。<br>我们需要使用一个 events 包：<br><code>npm install events --save</code></p>
<p>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; EventEmitter &#125; from &quot;events&quot;;</span><br><span class="line">export default new EventEmitter();</span><br></pre></td></tr></table></figure>
<p>App.js：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">import Foo from &quot;./Foo&quot;;</span><br><span class="line">import Boo from &quot;./Boo&quot;;</span><br><span class="line"></span><br><span class="line">import &quot;./App.css&quot;;</span><br><span class="line"></span><br><span class="line">export default class App extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Foo /&gt;</span><br><span class="line">                &lt;Boo /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Foo.js：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import emitter from &quot;./ev&quot;</span><br><span class="line"></span><br><span class="line">export default class Foo extends Component&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            msg:null,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        // 声明一个自定义事件</span><br><span class="line">        // 在组件装载完成以后</span><br><span class="line">        this.eventEmitter = emitter.addListener(&quot;callMe&quot;,(msg)=&gt;&#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                msg</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 组件销毁前移除事件监听</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        emitter.removeListener(this.eventEmitter);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123; this.state.msg &#125;</span><br><span class="line">                我是非嵌套 1 号</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Boo.js：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import emitter from &quot;./ev&quot;</span><br><span class="line"></span><br><span class="line">export default class Boo extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        const cb = (msg) =&gt; &#123;</span><br><span class="line">            return () =&gt; &#123;</span><br><span class="line">                // 触发自定义事件</span><br><span class="line">                emitter.emit(&quot;callMe&quot;,&quot;Hello&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                我是非嵌套 2 号</span><br><span class="line">                &lt;button onClick = &#123; cb(&quot;blue&quot;) &#125;&gt;点击我&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</p>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong><br>本文总结了 React 中组件的几种通信方式，分别是：</p>
<ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul>
<p>事实上，在组件间进行通信时，这些通信方式都可以使用，区别只在于使用相应的通信方式的复杂程度和个人喜好，选择最合适的那一个。比如，通过事件订阅模式通信不止可以应用在非嵌套组件间，还可以用于跨级组件间，非嵌套组件间通信也可以使用 context 等。关键是选择最合适的方式。</p>
<p>当然，自己实现组件间的通信还是太难以管理了，因此出现了很多状态管理工具，如 flux、redux 等，使用这些工具使得组件间的通信更容易追踪和管理。</p>
<hr>
<h4 id="11-React-Router及其简单实现原理"><a href="#11-React-Router及其简单实现原理" class="headerlink" title="11. React Router及其简单实现原理"></a>11. React Router及其简单实现原理</h4><blockquote>
<p><strong>极简版</strong></p>
</blockquote>
<p>获取html文件&#35;后面的部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.location.hash</span><br></pre></td></tr></table></figure></p>
<p>添加onhashchange事件，监听路由变化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange = function()&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#/home&quot;&gt;home&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#/index&quot;&gt;index&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#/other&quot;&gt;other&lt;/a&gt;</span><br><span class="line">&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.onhashchange = function()&#123;</span><br><span class="line">    var hash = window.location.hash.slice(1)</span><br><span class="line">    var box = document.getElementById(&apos;box&apos;)</span><br><span class="line">    if(hash==&apos;/home&apos;)&#123;</span><br><span class="line">        box.innerHTML = &quot;home&quot;</span><br><span class="line">    &#125;else if(hash==&apos;/index&apos;)&#123;</span><br><span class="line">        box.innerHTML = &quot;index&quot;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        box.innerHTML = &quot;default&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>详解版</strong></p>
</blockquote>
<blockquote>
<p>React Router 是一个基于 React 之上的强大路由库，它可以让你向应用中快速地添加视图和数据流，同时保持页面与 URL 间的同步。本文从两个方便来解析 react-router 实现原理。一：介绍 react-router 的依赖库history；二：使用 history 库，实现一个简单的 react-router 路由。</p>
</blockquote>
<p><strong>history 介绍</strong></p>
<blockquote>
<p>history 是一个 JavaScript 库，可让您在 JavaScript 运行的任何地方轻松管理会话历史记录。history 抽象出各种环境中的差异，并提供最小的 API ，使您可以管理历史堆栈，导航，确认导航以及在会话之间保持状态。</p>
</blockquote>
<p>history 有三种实现方式：</p>
<ol>
<li>BrowserHistory：用于支持 HTML5 历史记录 API 的现代 Web 浏览器（请参阅跨浏览器兼容性） </li>
<li>HashHistory：用于旧版Web浏览器</li>
<li>MemoryHistory：用作参考实现，也可用于非 DOM 环境，如 React Native 或测试</li>
</ol>
<p>三种实现方法，都是创建了一个 history 对象，这里主要讲下前面两种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const history = &#123;</span><br><span class="line">    length: globalHistory.length, </span><br><span class="line">    action: &quot;POP&quot;, </span><br><span class="line">    location: initialLocation,</span><br><span class="line">    createHref,</span><br><span class="line">    push, // 改变location</span><br><span class="line">    replace,</span><br><span class="line">    go,</span><br><span class="line">    goBack,</span><br><span class="line">    goForward,</span><br><span class="line">    block,</span><br><span class="line">    listen //监听路由变化</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>页面跳转实现<br>BrowserHistory：pushState、replaceState;<br>HashHistory：location.hash、location.replace</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function push()&#123;</span><br><span class="line">    createKey(); // 创建location的key，用于唯一标示该location，是随机生成的</span><br><span class="line">    if(BrowserHistory)&#123;</span><br><span class="line">        globalHistory.pushState(&#123; key, state &#125;, null, href);</span><br><span class="line">    &#125;else if(HashHistory)&#123;</span><br><span class="line">        window.location.hash = path;</span><br><span class="line">    &#125;</span><br><span class="line">    //上报listener 更新state ...</span><br><span class="line">&#125;</span><br><span class="line">function replace()&#123;</span><br><span class="line">    createKey(); // 创建location的key，用于唯一标示该location，是随机生成的</span><br><span class="line">    if(BrowserHistory)&#123;</span><br><span class="line">        globalHistory.replaceState(&#123; key, state &#125;, null, href); </span><br><span class="line">    &#125;else if(HashHistory)&#123;</span><br><span class="line">        window.location.replace(window.location.href.slice(0, hashIndex &gt;= 0 ? hashIndex : 0) + &quot;#&quot; path);</span><br><span class="line">    &#125; </span><br><span class="line">    //上报listener 更新state ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览器回退<br>BrowserHistory：popstate<br>HashHistory：hashchange</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if(BrowserHistory)&#123;</span><br><span class="line">    window.addEventListener(&quot;popstate&quot;, routerChange);</span><br><span class="line">&#125;else if(HashHistory)&#123;</span><br><span class="line">    window.addEventListener(&quot;hashchange&quot;, routerChange);</span><br><span class="line">&#125;</span><br><span class="line">function routerChange()&#123;</span><br><span class="line">    const location = getDOMLocation(); //获取location</span><br><span class="line">    //路由切换</span><br><span class="line">    transitionManager.confirmTransitionTo(location,callback=()=&gt;&#123;</span><br><span class="line">        //上报listener</span><br><span class="line">        transitionManager.notifyListeners();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过 history 实现简单 react-router<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import createHistory from &apos;history/createHashHistory&apos;;</span><br><span class="line">const history = createHistory(); //创建 history 对象</span><br><span class="line"></span><br><span class="line">//配置路由表</span><br><span class="line"></span><br><span class="line">const router = &#123;</span><br><span class="line"> &apos;/&apos;: &apos;page/home/index&apos;,</span><br><span class="line"> &apos;/my&apos;: &apos;page/my/index&apos;</span><br><span class="line">&#125;</span><br><span class="line">export default class Router extends Component &#123;</span><br><span class="line">    state = &#123; page: null &#125;</span><br><span class="line">    </span><br><span class="line">    async route(location) &#123;</span><br><span class="line">        let pathname = location.pathname;</span><br><span class="line">        let pagePath = router[pathname];</span><br><span class="line">        // 加 ./的原因 https://webpack.docschina.org/api/module-methods#import-</span><br><span class="line">        const Page = await import(`./$&#123;pagePath&#125;`); //获取路由对应的ui</span><br><span class="line">        //设置ui</span><br><span class="line">        this.setState(&#123; </span><br><span class="line">            Page: Page.default</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    initListener()&#123;</span><br><span class="line">        //监听路由切换</span><br><span class="line">        history.listen((location, action) =&gt; &#123;</span><br><span class="line">            //切换路由后，更新ui</span><br><span class="line">            this.route(location);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        this.route(history.location);</span><br><span class="line">        this.initListener();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; Page &#125; = this.state;</span><br><span class="line">        return Page &amp;&amp; &lt;Page &#123;...this.props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前react-router在项目中已有大量实践，其优点可以总结如下:</p>
<p>风格: 与React融为一体，专为react量身打造，编码风格与react保持一致，例如路由的配置可以通过component来实现</p>
<p>简单: 不需要手工维护路由state，使代码变得简单</p>
<p>强大: 强大的路由管理机制，体现在如下方面</p>
<ul>
<li>路由配置: 可以通过组件、配置对象来进行路由的配置</li>
<li>路由切换: 可以通过&#60;Link&#62; Redirect进行路由的切换</li>
<li>路由加载: 可以同步记载，也可以异步加载，这样就可以实现按需加载</li>
<li>使用方式: 不仅可以在浏览器端的使用，而且可以在服务器端的使用</li>
</ul>
<p>当然react-router的缺点就是API不太稳定，在升级版本的时候需要进行代码变动。</p>
<hr>
<h4 id="12-Redux数据流向及三个中间件（redux-logger、redux-thunk、redux-saga）"><a href="#12-Redux数据流向及三个中间件（redux-logger、redux-thunk、redux-saga）" class="headerlink" title="12. Redux数据流向及三个中间件（redux-logger、redux-thunk、redux-saga）"></a>12. Redux数据流向及三个中间件（redux-logger、redux-thunk、redux-saga）</h4>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title="0" data-url="http://link.hhtjim.com/163/5146554.mp3"></li>
                    
                        <li title="1" data-url="http://link.hhtjim.com/qq/001faIUs4M2zna.mp3"></li>
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="" data-cs="" data-r="" data-o="" data-a="" data-d="false">查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-什么是MVVM？"><span class="toc-number">1.</span> <span class="toc-text">1. 什么是MVVM？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#什么是MVVM"><span class="toc-number">1.1.</span> <span class="toc-text">什么是MVVM</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-React与Vue的区别与联系？"><span class="toc-number">2.</span> <span class="toc-text">2. React与Vue的区别与联系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-什么是JSX语法、Virtual-DOM与DOM-Diff算法？"><span class="toc-number">3.</span> <span class="toc-text">3. 什么是JSX语法、Virtual DOM与DOM Diff算法？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JSX语法"><span class="toc-number">3.1.</span> <span class="toc-text">JSX语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Virtual-DOM"><span class="toc-number">3.2.</span> <span class="toc-text">Virtual DOM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DOM-Diff算法"><span class="toc-number">3.3.</span> <span class="toc-text">DOM Diff算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-详细介绍生命周期-三个阶段，生命周期的触发顺序"><span class="toc-number">4.</span> <span class="toc-text">4. 详细介绍生命周期(三个阶段，生命周期的触发顺序)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-合成事件与改变this指向的三种方式及之间的区别？"><span class="toc-number">5.</span> <span class="toc-text">5. 合成事件与改变this指向的三种方式及之间的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#合成事件"><span class="toc-number">5.1.</span> <span class="toc-text">合成事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#改变this指向的三种方式及之间的区别"><span class="toc-number">5.2.</span> <span class="toc-text">改变this指向的三种方式及之间的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-样式绑定与CSS-Modules"><span class="toc-number">6.</span> <span class="toc-text">6. 样式绑定与CSS Modules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-多种组件创建方式及其区别？"><span class="toc-number">7.</span> <span class="toc-text">7. 多种组件创建方式及其区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-什么是受控组件？"><span class="toc-number">8.</span> <span class="toc-text">8. 什么是受控组件？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-高阶组件与装饰器"><span class="toc-number">9.</span> <span class="toc-text">9. 高阶组件与装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-组件通信的多种方式及其之间的区别"><span class="toc-number">10.</span> <span class="toc-text">10. 组件通信的多种方式及其之间的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-React-Router及其简单实现原理"><span class="toc-number">11.</span> <span class="toc-text">11. React Router及其简单实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-Redux数据流向及三个中间件（redux-logger、redux-thunk、redux-saga）"><span class="toc-number">12.</span> <span class="toc-text">12. Redux数据流向及三个中间件（redux-logger、redux-thunk、redux-saga）</span></a></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>